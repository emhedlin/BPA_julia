mark.occ
for (i in 1:sum(marked)){
CH[i, mark.occ[i]] <- 1       # Write an 1 at the release occasion
if (mark.occ[i]==n.occasions) next
for (t in (mark.occ[i]+1):n.occasions){
# Bernoulli trial: does individual survive occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
if (sur==0) break		# If dead, move to next individual
# Bernoulli trial: is individual recaptured?
rp <- rbinom(1, 1, P[i,t-1])
if (rp==1) CH[i,t] <- 1
} #t
} #i
CH
CH
ncol(CH)
for (i in 1:ncol(CH)){
sum(CH[,i])
}
for (i in 1:ncol(CH)){
print(sum(CH[,i]))
}
# Execute function
CH <- simul.cjs(PHI, P, marked)
sum(CH)
# Execute function
CH <- []
# Execute function
CH <- vector()
# Execute function
CH <- vector()
for (i in 1:100){
CH[i] <- sum(simul.cjs(PHI, P, marked))
}
mean(CH)
# Execute function
CH <- vector()
for (i in 1:1000){
CH[i] <- sum(simul.cjs(PHI, P, marked))
}
mean(CH)
# Create vector with occasion of marking
get.first <- function(x) min(which(x!=0))
f <- apply(CH, 1, get.first)
CH <- simul.cjs(PHI, P, marked)
# Create vector with occasion of marking
get.first <- function(x) min(which(x!=0))
f <- apply(CH, 1, get.first)
f
library(R2WinBUGS)
# 7.3. Models with constant parameters
# Define parameter values
n.occasions <- 6                   # Number of capture occasions
marked <- rep(50, n.occasions-1)   # Annual number of newly marked individuals
phi <- rep(0.65, n.occasions-1)
p <- rep(0.4, n.occasions-1)
# Define matrices with survival and recapture probabilities
PHI <- matrix(phi, ncol = n.occasions-1, nrow = sum(marked))
PHI_ <- matrix(0.65, ncol = n.occasions-1, nrow = sum(marked))
dim(PHI)
P <- matrix(p, ncol = n.occasions-1, nrow = sum(marked))
# Define function to simulate a capture-history (CH) matrix
simul.cjs <- function(PHI, P, marked){
n.occasions <- dim(PHI)[2] + 1
CH <- matrix(0, ncol = n.occasions, nrow = sum(marked))
# Define a vector with the occasion of marking
mark.occ <- rep(1:length(marked), marked[1:length(marked)])
# Fill the CH matrix
for (i in 1:sum(marked)){
CH[i, mark.occ[i]] <- 1       # Write an 1 at the release occasion
if (mark.occ[i]==n.occasions) next
for (t in (mark.occ[i]+1):n.occasions){
# Bernoulli trial: does individual survive occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
if (sur==0) break		# If dead, move to next individual
# Bernoulli trial: is individual recaptured?
rp <- rbinom(1, 1, P[i,t-1])
if (rp==1) CH[i,t] <- 1
} #t
} #i
return(CH)
}
for (i in 1:ncol(CH)){
print(sum(CH[,i]))
}
# Execute function
CH <- vector()
for (i in 1:1000){
CH[i] <- sum(simul.cjs(PHI, P, marked))
}
mean(CH)
CH <- simul.cjs(PHI, P, marked)
# Create vector with occasion of marking
get.first <- function(x) min(which(x!=0))
f <- apply(CH, 1, get.first)
# 7.3. Models with constant parameters
# Define parameter values
n.occasions <- 6                   # Number of capture occasions
marked <- rep(50, n.occasions-1)   # Annual number of newly marked individuals
phi <- rep(0.65, n.occasions-1)
p <- rep(0.4, n.occasions-1)
# Define matrices with survival and recapture probabilities
PHI <- matrix(phi, ncol = n.occasions-1, nrow = sum(marked))
PHI_ <- matrix(0.65, ncol = n.occasions-1, nrow = sum(marked))
dim(PHI)
P <- matrix(p, ncol = n.occasions-1, nrow = sum(marked))
# Define function to simulate a capture-history (CH) matrix
simul.cjs <- function(PHI, P, marked){
n.occasions <- dim(PHI)[2] + 1
CH <- matrix(0, ncol = n.occasions, nrow = sum(marked))
# Define a vector with the occasion of marking
mark.occ <- rep(1:length(marked), marked[1:length(marked)])
# Fill the CH matrix
for (i in 1:sum(marked)){
CH[i, mark.occ[i]] <- 1       # Write an 1 at the release occasion
if (mark.occ[i]==n.occasions) next
for (t in (mark.occ[i]+1):n.occasions){
# Bernoulli trial: does individual survive occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
if (sur==0) break		# If dead, move to next individual
# Bernoulli trial: is individual recaptured?
rp <- rbinom(1, 1, P[i,t-1])
if (rp==1) CH[i,t] <- 1
} #t
} #i
return(CH)
}
for (i in 1:ncol(CH)){
print(sum(CH[,i]))
}
# Execute function
CH <- vector()
for (i in 1:1000){
CH[i] <- sum(simul.cjs(PHI, P, marked))
}
mean(CH)
CH <- simul.cjs(PHI, P, marked)
# Create vector with occasion of marking
get.first <- function(x) min(which(x!=0))
f <- apply(CH, 1, get.first)
# Specify model in BUGS language
sink("cjs-c-c.bug")
cat("
model {
# Priors and constraints
for (i in 1:nind){
for (t in f[i]:(n.occasions-1)){
phi[i,t] <- mean.phi
p[i,t] <- mean.p
} #t
} #i
mean.phi ~ dunif(0, 1)         # Prior for mean survival
mean.p ~ dunif(0, 1)           # Prior for mean recapture
# Likelihood
for (i in 1:nind){
# Define latent state at first capture
z[i,f[i]] <- 1
for (t in (f[i]+1):n.occasions){
# State process
z[i,t] ~ dbern(mu1[i,t])
mu1[i,t] <- phi[i,t-1] * z[i,t-1]
# Observation process
y[i,t] ~ dbern(mu2[i,t])
mu2[i,t] <- p[i,t-1] * z[i,t]
} #t
} #i
}
",fill = TRUE)
sink()
# Bundle data
bugs.data <- list(y = CH,
f = f,
nind = dim(CH)[1],
n.occasions = dim(CH)[2])
# Function to create a matrix of initial values for latent state z
ch.init <- function(ch, f){
for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}
return(ch)
}
# Initial values
inits <- function(){list(z = ch.init(CH, f), mean.phi = runif(1, 0, 1), mean.p = runif(1, 0, 1))}
# Parameters monitored
parameters <- c("mean.phi", "mean.p")
# MCMC settings
ni <- 2000
nt <- 6
nb <- 5000
nc <- 1
# Call WinBUGS from R (BRT 1 min)
cjs.c.c <- bugs(bugs.data, inits, parameters, "cjs-c-c.bug", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, debug = TRUE, bugs.directory = bugs.dir, working.directory = getwd())
library(R2jags)
# 7.3. Models with constant parameters
# Define parameter values
n.occasions <- 6                   # Number of capture occasions
marked <- rep(50, n.occasions-1)   # Annual number of newly marked individuals
phi <- rep(0.65, n.occasions-1)
p <- rep(0.4, n.occasions-1)
# Define matrices with survival and recapture probabilities
PHI <- matrix(phi, ncol = n.occasions-1, nrow = sum(marked))
PHI_ <- matrix(0.65, ncol = n.occasions-1, nrow = sum(marked))
dim(PHI)
P <- matrix(p, ncol = n.occasions-1, nrow = sum(marked))
# Define function to simulate a capture-history (CH) matrix
simul.cjs <- function(PHI, P, marked){
n.occasions <- dim(PHI)[2] + 1
CH <- matrix(0, ncol = n.occasions, nrow = sum(marked))
# Define a vector with the occasion of marking
mark.occ <- rep(1:length(marked), marked[1:length(marked)])
# Fill the CH matrix
for (i in 1:sum(marked)){
CH[i, mark.occ[i]] <- 1       # Write an 1 at the release occasion
if (mark.occ[i]==n.occasions) next
for (t in (mark.occ[i]+1):n.occasions){
# Bernoulli trial: does individual survive occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
if (sur==0) break		# If dead, move to next individual
# Bernoulli trial: is individual recaptured?
rp <- rbinom(1, 1, P[i,t-1])
if (rp==1) CH[i,t] <- 1
} #t
} #i
return(CH)
}
for (i in 1:ncol(CH)){
print(sum(CH[,i]))
}
# Execute function
CH <- vector()
for (i in 1:1000){
CH[i] <- sum(simul.cjs(PHI, P, marked))
}
mean(CH)
CH <- simul.cjs(PHI, P, marked)
# Create vector with occasion of marking
get.first <- function(x) min(which(x!=0))
f <- apply(CH, 1, get.first)
# Specify model in BUGS language
sink("cjs-c-c.bug")
cat("
model {
# Priors and constraints
for (i in 1:nind){
for (t in f[i]:(n.occasions-1)){
phi[i,t] <- mean.phi
p[i,t] <- mean.p
} #t
} #i
mean.phi ~ dunif(0, 1)         # Prior for mean survival
mean.p ~ dunif(0, 1)           # Prior for mean recapture
# Likelihood
for (i in 1:nind){
# Define latent state at first capture
z[i,f[i]] <- 1
for (t in (f[i]+1):n.occasions){
# State process
z[i,t] ~ dbern(mu1[i,t])
mu1[i,t] <- phi[i,t-1] * z[i,t-1]
# Observation process
y[i,t] ~ dbern(mu2[i,t])
mu2[i,t] <- p[i,t-1] * z[i,t]
} #t
} #i
}
",fill = TRUE)
sink()
length(f)
# Bundle data
bugs.data <- list(y = CH,
f = f,
nind = dim(CH)[1],
n.occasions = dim(CH)[2])
# Function to create a matrix of initial values for latent state z
ch.init <- function(ch, f){
for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}
return(ch)
}
# Initial values
inits <- function(){list(z = ch.init(CH, f), mean.phi = runif(1, 0, 1), mean.p = runif(1, 0, 1))}
# Parameters monitored
parameters <- c("mean.phi", "mean.p")
# MCMC settings
ni <- 2000
nt <- 6
nb <- 5000
nc <- 1
# Call WinBUGS from R (BRT 1 min)
cjs.c.c <- jags(bugs.data, inits, parameters, "cjs-c-c.bug", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, debug = TRUE, bugs.directory = bugs.dir, working.directory = getwd())
# Call WinBUGS from R (BRT 1 min)
cjs.c.c <- jags(bugs.data, inits, parameters, "cjs-c-c.bug", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)
# Bundle data
bugs.data <- list(y = CH,
f = f,
nind = dim(CH)[1],
n.occasions = dim(CH)[2])
# Function to create a matrix of initial values for latent state z
ch.init <- function(ch, f){
for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}
return(ch)
}
# Initial values
inits <- function(){list(z = ch.init(CH, f), mean.phi = runif(1, 0, 1), mean.p = runif(1, 0, 1))}
# Parameters monitored
parameters <- c("mean.phi", "mean.p")
# MCMC settings
ni <- 2000
nt <- 6
nb <- 5000
nc <- 1
# Call WinBUGS from R (BRT 1 min)
cjs.c.c <- jags(bugs.data, inits, parameters, "cjs-c-c.bug", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)
?jags
# Call WinBUGS from R (BRT 1 min)
cjs.c.c <- jags(bugs.data, inits = NULL, parameters, "cjs-c-c.bug", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)
# Initial values
inits <- function(){list(z = ch.init(CH, f), mean.phi = runif(1, 0, 1), mean.p = runif(1, 0, 1))}
# Call WinBUGS from R (BRT 1 min)
cjs.c.c <- jags(bugs.data, inits = inits, parameters, "cjs-c-c.bug", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb)
library(R2WinBUGS)
# 7.3. Models with constant parameters
# Define parameter values
n.occasions <- 6                   # Number of capture occasions
marked <- rep(50, n.occasions-1)   # Annual number of newly marked individuals
phi <- rep(0.65, n.occasions-1)
p <- rep(0.4, n.occasions-1)
# Define matrices with survival and recapture probabilities
PHI <- matrix(phi, ncol = n.occasions-1, nrow = sum(marked))
P <- matrix(p, ncol = n.occasions-1, nrow = sum(marked))
# Define function to simulate a capture-history (CH) matrix
simul.cjs <- function(PHI, P, marked){
n.occasions <- dim(PHI)[2] + 1
CH <- matrix(0, ncol = n.occasions, nrow = sum(marked))
# Define a vector with the occasion of marking
mark.occ <- rep(1:length(marked), marked[1:length(marked)])
# Fill the CH matrix
for (i in 1:sum(marked)){
CH[i, mark.occ[i]] <- 1       # Write an 1 at the release occasion
if (mark.occ[i]==n.occasions) next
for (t in (mark.occ[i]+1):n.occasions){
# Bernoulli trial: does individual survive occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
if (sur==0) break		# If dead, move to next individual
# Bernoulli trial: is individual recaptured?
rp <- rbinom(1, 1, P[i,t-1])
if (rp==1) CH[i,t] <- 1
} #t
} #i
return(CH)
}
# Execute function
CH <- simul.cjs(PHI, P, marked)
# Create vector with occasion of marking
get.first <- function(x) min(which(x!=0))
f <- apply(CH, 1, get.first)
# Specify model in BUGS language
sink("cjs-c-c.bug")
cat("
model {
# Priors and constraints
for (i in 1:nind){
for (t in f[i]:(n.occasions-1)){
phi[i,t] <- mean.phi
p[i,t] <- mean.p
} #t
} #i
mean.phi ~ dunif(0, 1)         # Prior for mean survival
mean.p ~ dunif(0, 1)           # Prior for mean recapture
# Likelihood
for (i in 1:nind){
# Define latent state at first capture
z[i,f[i]] <- 1
for (t in (f[i]+1):n.occasions){
# State process
z[i,t] ~ dbern(mu1[i,t])
mu1[i,t] <- phi[i,t-1] * z[i,t-1]
# Observation process
y[i,t] ~ dbern(mu2[i,t])
mu2[i,t] <- p[i,t-1] * z[i,t]
} #t
} #i
}
",fill = TRUE)
sink()
# Bundle data
bugs.data <- list(y = CH, f = f, nind = dim(CH)[1], n.occasions = dim(CH)[2])
# Function to create a matrix of initial values for latent state z
ch.init <- function(ch, f){
for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}
return(ch)
}
# Initial values
inits <- function(){list(z = ch.init(CH, f), mean.phi = runif(1, 0, 1), mean.p = runif(1, 0, 1))}
# Parameters monitored
parameters <- c("mean.phi", "mean.p")
# MCMC settings
ni <- 10000
nt <- 6
nb <- 5000
nc <- 3
# Call WinBUGS from R (BRT 1 min)
cjs.c.c <- bugs(bugs.data, inits, parameters, "cjs-c-c.bug", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, debug = TRUE, bugs.directory = bugs.dir, working.directory = getwd())
library(R2jags)
# 7.3. Models with constant parameters
# Define parameter values
n.occasions <- 6                   # Number of capture occasions
marked <- rep(50, n.occasions-1)   # Annual number of newly marked individuals
phi <- rep(0.65, n.occasions-1)
p <- rep(0.4, n.occasions-1)
# Define matrices with survival and recapture probabilities
PHI <- matrix(phi, ncol = n.occasions-1, nrow = sum(marked))
P <- matrix(p, ncol = n.occasions-1, nrow = sum(marked))
# Define function to simulate a capture-history (CH) matrix
simul.cjs <- function(PHI, P, marked){
n.occasions <- dim(PHI)[2] + 1
CH <- matrix(0, ncol = n.occasions, nrow = sum(marked))
# Define a vector with the occasion of marking
mark.occ <- rep(1:length(marked), marked[1:length(marked)])
# Fill the CH matrix
for (i in 1:sum(marked)){
CH[i, mark.occ[i]] <- 1       # Write an 1 at the release occasion
if (mark.occ[i]==n.occasions) next
for (t in (mark.occ[i]+1):n.occasions){
# Bernoulli trial: does individual survive occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
if (sur==0) break		# If dead, move to next individual
# Bernoulli trial: is individual recaptured?
rp <- rbinom(1, 1, P[i,t-1])
if (rp==1) CH[i,t] <- 1
} #t
} #i
return(CH)
}
# Execute function
CH <- simul.cjs(PHI, P, marked)
# Create vector with occasion of marking
get.first <- function(x) min(which(x!=0))
f <- apply(CH, 1, get.first)
# Specify model in BUGS language
sink("cjs-c-c.bug")
cat("
model {
# Priors and constraints
for (i in 1:nind){
for (t in f[i]:(n.occasions-1)){
phi[i,t] <- mean.phi
p[i,t] <- mean.p
} #t
} #i
mean.phi ~ dunif(0, 1)         # Prior for mean survival
mean.p ~ dunif(0, 1)           # Prior for mean recapture
# Likelihood
for (i in 1:nind){
# Define latent state at first capture
z[i,f[i]] <- 1
for (t in (f[i]+1):n.occasions){
# State process
z[i,t] ~ dbern(mu1[i,t])
mu1[i,t] <- phi[i,t-1] * z[i,t-1]
# Observation process
y[i,t] ~ dbern(mu2[i,t])
mu2[i,t] <- p[i,t-1] * z[i,t]
} #t
} #i
}
",fill = TRUE)
sink()
# Bundle data
bugs.data <- list(y = CH, f = f, nind = dim(CH)[1], n.occasions = dim(CH)[2])
# Function to create a matrix of initial values for latent state z
ch.init <- function(ch, f){
for (i in 1:dim(ch)[1]){ch[i,1:f[i]] <- NA}
return(ch)
}
# Initial values
inits <- function(){list(z = ch.init(CH, f), mean.phi = runif(1, 0, 1), mean.p = runif(1, 0, 1))}
# Parameters monitored
parameters <- c("mean.phi", "mean.p")
# 7.3. Models with constant parameters
# Define parameter values
n.occasions <- 6                   # Number of capture occasions
marked <- rep(50, n.occasions-1)   # Annual number of newly marked individuals
phi <- rep(0.65, n.occasions-1)
p <- rep(0.4, n.occasions-1)
# Define matrices with survival and recapture probabilities
PHI <- matrix(phi, ncol = n.occasions-1, nrow = sum(marked))
P <- matrix(p, ncol = n.occasions-1, nrow = sum(marked))
# Define function to simulate a capture-history (CH) matrix
simul.cjs <- function(PHI, P, marked){
n.occasions <- dim(PHI)[2] + 1
CH <- matrix(0, ncol = n.occasions, nrow = sum(marked))
# Define a vector with the occasion of marking
mark.occ <- rep(1:length(marked), marked[1:length(marked)])
# Fill the CH matrix
for (i in 1:sum(marked)){
CH[i, mark.occ[i]] <- 1       # Write an 1 at the release occasion
if (mark.occ[i]==n.occasions) next
for (t in (mark.occ[i]+1):n.occasions){
# Bernoulli trial: does individual survive occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
if (sur==0) break		# If dead, move to next individual
# Bernoulli trial: is individual recaptured?
rp <- rbinom(1, 1, P[i,t-1])
if (rp==1) CH[i,t] <- 1
} #t
} #i
return(CH)
}
# Execute function
CH <- simul.cjs(PHI, P, marked)
CH
write.csv(CH, "data/7_3_data.csv")
?qlogis
qlogis(0.9)
